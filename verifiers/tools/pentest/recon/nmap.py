from __future__ import annotations

import re
import shlex
import shutil
from typing import List

# Re-use the generic shell helper that already exists for running commands safely
try:
    from ..shell import shell  # type: ignore
except ImportError:
    # Fallback for static analysers/tests that import the file directly
    from verifiers.tools.pentest.shell import shell  # type: ignore


def _sanitize_target(target: str) -> str:
    """Return a sanitised version of *target* or raise ``ValueError``.

    Only allow hostnames or IPv4 addresses consisting of letters, digits, dots
    and dashes. This prevents command-injection attempts such as
    "example.com; rm -rf /".
    """
    if not re.fullmatch(r"[A-Za-z0-9.\-]+", target):
        raise ValueError("Invalid target – only letters, digits, dots and dashes are allowed.")
    return target


def _sanitize_flags(flags: str) -> str:
    """Ensure *flags* only contains safe nmap options.

    The function allows a curated subset of common, non-destructive flags. Any
    disallowed flag triggers a ``ValueError`` to avoid running dangerous or
    privileged scans.
    """
    allowed = {
        "-sV", "-sS", "-sT", "-O", "-Pn", "-F", "-sC", "-A", "-T0", "-T1", "-T2",
        "-T3", "-T4", "-T5", "-p", "--top-ports", "--version-light",
    }

    # Split respecting quoted sections, then validate flag by flag
    parts = shlex.split(flags)
    for p in parts:
        # Allow port ranges after -p & numeric arguments for --top-ports
        if p.startswith("-p") or p == "-p":
            continue
        if p.startswith("--top-ports") or p == "--top-ports":
            continue
        if p not in allowed:
            raise ValueError(f"Flag '{p}' is not allowed.")
    return " ".join(parts)


def _parse_nmap_output(lines: List[str]) -> str:
    """Extract a concise summary from raw nmap output."""
    open_ports = []
    collecting = False
    for line in lines:
        line = line.strip()
        # The port table starts after a line that begins with "PORT".
        if line.startswith("PORT"):
            collecting = True
            continue
        if collecting:
            if not line or line.startswith("Nmap done"):
                break
            # Only keep lines where state is open|filtered or open
            if "/" in line and "open" in line:
                # Format like "80/tcp   open  http"
                open_ports.append(line)
    if not open_ports:
        return "No open ports found (or scan failed)."
    summary = ["Open ports:"] + [f"• {p}" for p in open_ports]
    return "\n".join(summary)


def nmap_scan(target: str, flags: str = "-sV -T4 -F") -> str:  # noqa: D401
    """Run an *nmap* scan against *target* and return a concise report.

    Args:
        target: IPv4 address or hostname to scan (e.g. "scanme.nmap.org").
        flags: Additional nmap flags. A curated subset is allowed (default:
            "-sV -T4 -F").

    Returns:
        A human-readable summary of open ports/services or an error message.

    Examples:
        {"target": "scanme.nmap.org"} -> "Open ports:\n• 22/tcp  open  ssh\n• 80/tcp  open  http"
    """
    try:
        # Ensure nmap binary exists first
        if not shutil.which("nmap"):
            return "Error: nmap is not installed in this environment."

        safe_target = _sanitize_target(target)
        safe_flags = _sanitize_flags(flags)

        cmd = f"nmap {safe_flags} {safe_target}"
        output = shell(cmd, timeout=120)

        # If helper already returned an error, propagate
        if output.startswith("Error:"):
            return output

        # Parse to summary, truncating long outputs (>3000 chars)
        summary = _parse_nmap_output(output.splitlines())
        if len(summary) > 3000:
            summary = summary[:3000] + "\n... (truncated)"
        return summary
    except ValueError as ve:
        return f"Error: {ve}"
    except Exception as e:
        return f"Error: {str(e)}"
