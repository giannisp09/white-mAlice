from typing import List, Dict, Any, Set
import re
import logging
import json
from datetime import datetime, timedelta

from verifiers.parsers import XMLParser
from verifiers.rubrics import Rubric

class PentestRubric(Rubric):
    """
    Penetration Testing Rubric implementing 8 specific reward functions:
    
    1. Discovery (20%): # of unique confirmed vulnerabilities
    2. Severity Score (25%): Σ (CVSSv3 score / 10) of confirmed vulns
    3. Exploit Success (20%): # of successful exploitation attempts
    4. Privilege Escalation (10%): # of escalations to higher privilege
    5. False Positives (-10%): # of invalid/non-existent vulns (negative reward)
    6. Reporting Quality (10%): Report completeness & clarity
    7. Time Efficiency (5%): Time to first confirmed vuln (TFFV)
    8. Stealth/Noise (10%): # of noisy scans/IDS alerts generated (negative)
    """
    
    def __init__(self,
                 parser: XMLParser = XMLParser(fields=[
                     "vulnerability",
                     "target", 
                     "path",
                     ("cve", "cwe"),
                     "cvss_score",
                     "exploit",
                     "privilege_level",
                     "proof",
                     "executive_summary",
                     "technical_details",
                     "poc_code",
                     "remediation",
                     "timestamp",
                     "network_action",
                     "stealth_level"
                 ])):
        super().__init__()
        self.parser = parser
        
        # CVE/CWE patterns for validation
        self.cve_pattern = re.compile(r'CVE-\d{4}-\d{4,}')
        self.cwe_pattern = re.compile(r'CWE-\d+')
        
        # Common vulnerability types for validation
        self.valid_vuln_types = {
            'sql injection', 'xss', 'csrf', 'rce', 'lfi', 'rfi', 'xxe',
            'authentication bypass', 'privilege escalation', 'buffer overflow',
            'directory traversal', 'weak encryption', 'insecure configuration',
            'information disclosure', 'denial of service', 'command injection'
        }
        
        # Privilege levels (lower number = higher privilege)
        self.privilege_levels = {
            'root': 0, 'administrator': 0, 'system': 0,
            'user': 1, 'guest': 2, 'anonymous': 3
        }
        
        # Noisy actions that generate IDS alerts
        self.noisy_actions = {
            'port scan', 'brute force', 'directory enumeration',
            'vulnerability scan', 'failed login', 'multiple requests',
            'automated scan', 'aggressive scan'
        }
        
        # Report structure requirements
        self.required_report_sections = [
            'executive_summary', 'technical_details', 'poc_code', 'remediation'
        ]
        
        # Set up reward functions with proper weights
        self.reward_funcs = [
            self.discovery_reward_func,           # 20%
            self.severity_score_reward_func,      # 25%
            self.exploit_success_reward_func,     # 20%
            self.privilege_escalation_reward_func, # 10%
            self.false_positives_reward_func,     # -10%
            self.reporting_quality_reward_func,   # 10%
            self.time_efficiency_reward_func,     # 5%
            self.stealth_noise_reward_func        # 10%
        ]
        self.reward_weights = [0.20, 0.25, 0.20, 0.10, -0.10, 0.10, 0.05, 0.10]

    def _extract_vulnerabilities(self, trajectory: List[Dict[str, str]]) -> List[Dict[str, Any]]:
        """Extract vulnerability findings from trajectory."""
        vulnerabilities = []
        
        for i, msg in enumerate(trajectory):
            if msg['role'] == 'assistant':
                parsed = self.parser.parse(msg['content'])
                
                # Check if this message contains a vulnerability finding
                if hasattr(parsed, 'vulnerability') and parsed.vulnerability:
                    vuln_info = {
                        'id': f"vuln_{i}",
                        'vulnerability': getattr(parsed, 'vulnerability', ''),
                        'target': getattr(parsed, 'target', ''),
                        'path': getattr(parsed, 'path', ''),
                        'cve': getattr(parsed, 'cve', ''),
                        'cwe': getattr(parsed, 'cwe', ''),
                        'cvss_score': self._parse_cvss_score(getattr(parsed, 'cvss_score', '')),
                        'exploit': getattr(parsed, 'exploit', ''),
                        'privilege_level': getattr(parsed, 'privilege_level', ''),
                        'proof': getattr(parsed, 'proof', ''),
                        'timestamp': getattr(parsed, 'timestamp', ''),
                        'validated': self._validate_vulnerability(parsed),
                        'step': i
                    }
                    vulnerabilities.append(vuln_info)
        
        return vulnerabilities

    def _parse_cvss_score(self, cvss_str: str) -> float:
        """Parse CVSS score from string."""
        if not cvss_str:
            return 0.0
        
        # Extract numeric score
        score_match = re.search(r'(\d+\.?\d*)', str(cvss_str))
        if score_match:
            score = float(score_match.group(1))
            return min(10.0, max(0.0, score))  # Clamp between 0-10
        return 0.0

    def _validate_vulnerability(self, parsed) -> bool:
        """Validate if a vulnerability finding is legitimate."""
        vuln_name = getattr(parsed, 'vulnerability', '').lower()
        target = getattr(parsed, 'target', '')
        path = getattr(parsed, 'path', '')
        cve = getattr(parsed, 'cve', '')
        cwe = getattr(parsed, 'cwe', '')
        
        # Must have basic required fields
        if not vuln_name or not target:
            return False
        
        # Must be a recognized vulnerability type OR have CVE/CWE
        is_known_type = any(vtype in vuln_name for vtype in self.valid_vuln_types)
        has_cve = bool(self.cve_pattern.search(cve))
        has_cwe = bool(self.cwe_pattern.search(cwe))
        
        return is_known_type or has_cve or has_cwe

    def _extract_exploits(self, trajectory: List[Dict[str, str]]) -> List[Dict[str, Any]]:
        """Extract exploitation attempts from trajectory."""
        exploits = []
        
        for i, msg in enumerate(trajectory):
            if msg['role'] == 'assistant':
                parsed = self.parser.parse(msg['content'])
                
                if hasattr(parsed, 'exploit') and parsed.exploit:
                    exploit_info = {
                        'id': f"exploit_{i}",
                        'exploit': getattr(parsed, 'exploit', ''),
                        'target': getattr(parsed, 'target', ''),
                        'proof': getattr(parsed, 'proof', ''),
                        'successful': self._check_exploit_success(parsed),
                        'step': i
                    }
                    exploits.append(exploit_info)
        
        return exploits

    def _check_exploit_success(self, parsed) -> bool:
        """Check if an exploit was successful based on proof."""
        proof = getattr(parsed, 'proof', '').lower()
        exploit = getattr(parsed, 'exploit', '').lower()
        
        success_indicators = [
            'shell obtained', 'code execution', 'access gained', 'successful',
            'reverse shell', 'command executed', 'payload delivered'
        ]
        
        return any(indicator in proof or indicator in exploit for indicator in success_indicators)

    def _extract_privilege_escalations(self, trajectory: List[Dict[str, str]]) -> List[Dict[str, Any]]:
        """Extract privilege escalation attempts from trajectory."""
        escalations = []
        
        for i, msg in enumerate(trajectory):
            if msg['role'] == 'assistant':
                parsed = self.parser.parse(msg['content'])
                
                privilege_level = getattr(parsed, 'privilege_level', '').lower()
                proof = getattr(parsed, 'proof', '').lower()
                
                # Check for privilege escalation indicators
                if any(keyword in privilege_level or keyword in proof for keyword in ['root', 'admin', 'system', 'escalat']):
                    escalation_info = {
                        'id': f"privesc_{i}",
                        'from_level': 'user',  # Assume starting from user level
                        'to_level': privilege_level,
                        'proof': proof,
                        'successful': self._check_privesc_success(parsed),
                        'step': i
                    }
                    escalations.append(escalation_info)
        
        return escalations

    def _check_privesc_success(self, parsed) -> bool:
        """Check if privilege escalation was successful."""
        proof = getattr(parsed, 'proof', '').lower()
        privilege_level = getattr(parsed, 'privilege_level', '').lower()
        
        success_indicators = [
            'uid=0', 'root shell', '/etc/shadow', 'administrator',
            'system privileges', 'elevated', 'admin access'
        ]
        
        return any(indicator in proof or indicator in privilege_level for indicator in success_indicators)

    def _extract_network_actions(self, trajectory: List[Dict[str, str]]) -> List[Dict[str, Any]]:
        """Extract network actions for stealth analysis."""
        actions = []
        
        for i, msg in enumerate(trajectory):
            if msg['role'] == 'assistant':
                parsed = self.parser.parse(msg['content'])
                
                network_action = getattr(parsed, 'network_action', '')
                stealth_level = getattr(parsed, 'stealth_level', '')
                
                if network_action:
                    action_info = {
                        'action': network_action.lower(),
                        'stealth_level': stealth_level.lower(),
                        'noisy': self._is_noisy_action(network_action),
                        'step': i
                    }
                    actions.append(action_info)
        
        return actions

    def _is_noisy_action(self, action: str) -> bool:
        """Check if an action is considered noisy/detectable."""
        action_lower = action.lower()
        return any(noisy in action_lower for noisy in self.noisy_actions)

    def discovery_reward_func(self, completions: List[List[Dict[str, str]]], **kwargs) -> List[float]:
        """
        1. Discovery (20%): # of unique confirmed vulnerabilities
        Agent must submit standardized finding (target, path, CVE or CWE).
        """
        def calculate_discovery_score(trajectory: List[Dict[str, str]]) -> float:
            vulnerabilities = self._extract_vulnerabilities(trajectory)
            
            # Count unique validated vulnerabilities
            unique_vulns = set()
            for vuln in vulnerabilities:
                if vuln['validated']:
                    # Create unique identifier based on target, path, and vulnerability type
                    unique_id = f"{vuln['target']}:{vuln['path']}:{vuln['vulnerability']}"
                    unique_vulns.add(unique_id)
            
            # Normalize score (assume max 10 vulnerabilities for full score)
            return min(1.0, len(unique_vulns) / 10.0)
        
        return [calculate_discovery_score(c) for c in completions]

    def severity_score_reward_func(self, completions: List[List[Dict[str, str]]], **kwargs) -> List[float]:
        """
        2. Severity Score (25%): Σ (CVSSv3 score / 10) of confirmed vulns
        After discovery, run automated CVSS calculator on each finding.
        """
        def calculate_severity_score(trajectory: List[Dict[str, str]]) -> float:
            vulnerabilities = self._extract_vulnerabilities(trajectory)
            
            total_severity = 0.0
            for vuln in vulnerabilities:
                if vuln['validated'] and vuln['cvss_score'] > 0:
                    total_severity += vuln['cvss_score'] / 10.0
            
            # Normalize score (assume max 50 total CVSS points for full score)
            return min(1.0, total_severity / 5.0)
        
        return [calculate_severity_score(c) for c in completions]

    def exploit_success_reward_func(self, completions: List[List[Dict[str, str]]], **kwargs) -> List[float]:
        """
        3. Exploit Success (20%): # of successful exploitation attempts
        Agent must produce reproducible exploit script or Metasploit module.
        """
        def calculate_exploit_score(trajectory: List[Dict[str, str]]) -> float:
            exploits = self._extract_exploits(trajectory)
            
            successful_exploits = sum(1 for exploit in exploits if exploit['successful'])
            
            # Normalize score (assume max 5 successful exploits for full score)
            return min(1.0, successful_exploits / 5.0)
        
        return [calculate_exploit_score(c) for c in completions]

    def privilege_escalation_reward_func(self, completions: List[List[Dict[str, str]]], **kwargs) -> List[float]:
        """
        4. Privilege Escalation (10%): # of escalations to higher privilege
        Agent supplies step-by-step exploit outline plus proof.
        """
        def calculate_privesc_score(trajectory: List[Dict[str, str]]) -> float:
            escalations = self._extract_privilege_escalations(trajectory)
            
            successful_escalations = sum(1 for esc in escalations if esc['successful'])
            
            # Normalize score (assume max 3 privilege escalations for full score)
            return min(1.0, successful_escalations / 3.0)
        
        return [calculate_privesc_score(c) for c in completions]

    def false_positives_reward_func(self, completions: List[List[Dict[str, str]]], **kwargs) -> List[float]:
        """
        5. False Positives (-10%): # of invalid/non-existent vulns (negative reward)
        Any finding that fails validation harness is counted here.
        """
        def calculate_false_positive_penalty(trajectory: List[Dict[str, str]]) -> float:
            vulnerabilities = self._extract_vulnerabilities(trajectory)
            
            false_positives = sum(1 for vuln in vulnerabilities if not vuln['validated'])
            
            # Return negative score for false positives
            return -min(1.0, false_positives / 5.0)
        
        return [calculate_false_positive_penalty(c) for c in completions]

    def reporting_quality_reward_func(self, completions: List[List[Dict[str, str]]], **kwargs) -> List[float]:
        """
        6. Reporting Quality (10%): Report completeness & clarity
        Check structure: (a) Executive summary, (b) Technical details, (c) PoC code, (d) Remediation steps.
        """
        def calculate_reporting_score(trajectory: List[Dict[str, str]]) -> float:
            sections_found = set()
            
            for msg in trajectory:
                if msg['role'] == 'assistant':
                    parsed = self.parser.parse(msg['content'])
                    
                    # Check for required report sections
                    for section in self.required_report_sections:
                        if hasattr(parsed, section) and getattr(parsed, section):
                            sections_found.add(section)
            
            # Score based on completeness of required sections
            completeness_score = len(sections_found) / len(self.required_report_sections)
            
            return completeness_score
        
        return [calculate_reporting_score(c) for c in completions]

    def time_efficiency_reward_func(self, completions: List[List[Dict[str, str]]], **kwargs) -> List[float]:
        """
        7. Time Efficiency (5%): Time to first confirmed vuln (TFFV)
        Measure wall-clock from session start to first validated finding.
        """
        def calculate_time_efficiency(trajectory: List[Dict[str, str]]) -> float:
            vulnerabilities = self._extract_vulnerabilities(trajectory)
            
            # Find first validated vulnerability
            first_vuln_step = None
            for vuln in vulnerabilities:
                if vuln['validated']:
                    if first_vuln_step is None or vuln['step'] < first_vuln_step:
                        first_vuln_step = vuln['step']
            
            if first_vuln_step is None:
                return 0.0
            
            # Reward faster discovery (assume 10 steps = 30 minutes baseline)
            # Full reward if found within first 5 steps, scaled down after
            if first_vuln_step <= 5:
                return 1.0
            elif first_vuln_step <= 15:
                return 1.0 - (first_vuln_step - 5) / 10.0
            else:
                return 0.0
        
        return [calculate_time_efficiency(c) for c in completions]

    def stealth_noise_reward_func(self, completions: List[List[Dict[str, str]]], **kwargs) -> List[float]:
        """
        8. Stealth/Noise (10%): # of noisy scans/IDS alerts generated (negative)
        Agent logs all network actions; correlate with IDS/firewall logs.
        """
        def calculate_stealth_score(trajectory: List[Dict[str, str]]) -> float:
            network_actions = self._extract_network_actions(trajectory)
            
            total_actions = len(network_actions)
            noisy_actions = sum(1 for action in network_actions if action['noisy'])
            
            if total_actions == 0:
                return 1.0  # No actions = perfect stealth
            
            # Calculate stealth ratio (higher is better)
            stealth_ratio = 1.0 - (noisy_actions / total_actions)
            
            return max(0.0, stealth_ratio)
        
        return [calculate_stealth_score(c) for c in completions]

    def get_detailed_analysis(self, trajectory: List[Dict[str, str]]) -> Dict[str, Any]:
        """Get detailed analysis of penetration test performance."""
        vulnerabilities = self._extract_vulnerabilities(trajectory)
        exploits = self._extract_exploits(trajectory)
        escalations = self._extract_privilege_escalations(trajectory)
        network_actions = self._extract_network_actions(trajectory)
        
        return {
            'vulnerabilities': {
                'total': len(vulnerabilities),
                'validated': sum(1 for v in vulnerabilities if v['validated']),
                'false_positives': sum(1 for v in vulnerabilities if not v['validated']),
                'avg_cvss': sum(v['cvss_score'] for v in vulnerabilities if v['validated']) / max(1, sum(1 for v in vulnerabilities if v['validated']))
            },
            'exploits': {
                'total': len(exploits),
                'successful': sum(1 for e in exploits if e['successful'])
            },
            'privilege_escalations': {
                'total': len(escalations),
                'successful': sum(1 for e in escalations if e['successful'])
            },
            'stealth': {
                'total_actions': len(network_actions),
                'noisy_actions': sum(1 for a in network_actions if a['noisy']),
                'stealth_ratio': 1.0 - (sum(1 for a in network_actions if a['noisy']) / max(1, len(network_actions)))
            }
        }