import subprocess
from typing import List, Dict, Any, Tuple

from verifiers.envs.multiturn_env import MultiTurnEnv
from verifiers.parsers import XMLParser
from verifiers.rubrics import PentestRubric

# Pentest-specific system prompt
PENTEST_PROMPT = """You are a penetration testing assistant. Your goal is to perform network reconnaissance using nmap and other shell commands to discover hosts, open ports, and services.

You should:
1. Use nmap commands to scan networks and hosts
2. Identify open ports and running services
3. Format your responses using XML tags: <command>, <output>, <host>, <port>, <service>

Example format:
<command>nmap -sS 192.168.1.1</command>
<output>Nmap scan report for 192.168.1.1
Host is up (0.001s latency).
PORT     STATE SERVICE
22/tcp   open  ssh
80/tcp   open  http
443/tcp  open  https</output>
<host>192.168.1.1</host>
<port>22,80,443</port>
<service>ssh,http,https</service>

Focus on gathering as much network information as possible through reconnaissance."""

class PentestEnv(MultiTurnEnv):
    def __init__(self,
                 system_prompt: str = PENTEST_PROMPT,
                 max_turns: int = 10,
                 **kwargs):
        parser = XMLParser(fields=[
            "command",
            "output", 
            ("host", "target"),
            ("port", "ports"),
            "service"
        ])
        self.env_parser = XMLParser(fields=["result"])
        rubric = PentestRubric(parser=parser)
        super().__init__(
            system_prompt=system_prompt,
            parser=parser,
            rubric=rubric,
            max_turns=max_turns,
            **kwargs
        )
    
    def is_completed(self,
                    messages: List[Dict[str, str]],
                    state: Dict[str, Any],
                    **kwargs: Any) -> bool:
        try:
            # Check if we have discovered some network information
            discovered_hosts = state.get('discovered_hosts', set())
            discovered_ports = state.get('discovered_ports', set())
            
            # Complete if we've discovered at least 1 host and 3 ports
            return len(discovered_hosts) >= 1 and len(discovered_ports) >= 3
        except Exception:
            return False

    def run_shell_command(self, command: str, **kwargs: Any) -> str:
        try:
            # For security, only allow specific safe commands
            allowed_commands = ['nmap', 'ping', 'traceroute', 'dig', 'nslookup', 'whois']
            
            # Check if command starts with allowed commands
            if not any(command.strip().startswith(cmd) for cmd in allowed_commands):
                return "Error: Command not allowed. Only network reconnaissance commands are permitted."
            
            # Run the shell command with timeout
            result = subprocess.run(
                command,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                timeout=30,
                text=True
            )
            
            if result.stderr:
                return f"Error: {result.stderr.strip()}"
            return result.stdout.strip() if result.stdout else "Command completed successfully."
            
        except subprocess.TimeoutExpired:
            return "Error: Command execution timed out after 30 seconds"
        except Exception as e:
            return f"Error: {str(e)}"

    def update_discovery_state(self, parsed, state: Dict[str, Any]) -> Dict[str, Any]:
        """Update state with discovered network information."""
        if not hasattr(parsed, 'output') or not parsed.output:
            return state
            
        output = parsed.output
        
        # Initialize discovery sets if not present
        if 'discovered_hosts' not in state:
            state['discovered_hosts'] = set()
        if 'discovered_ports' not in state:
            state['discovered_ports'] = set()
        if 'discovered_services' not in state:
            state['discovered_services'] = set()
        
        # Extract hosts from nmap output
        import re
        host_matches = re.findall(r'Nmap scan report for ([\d\.]+)', output)
        state['discovered_hosts'].update(host_matches)
        
        # Extract open ports
        port_matches = re.findall(r'(\d+/\w+)\s+open', output)
        state['discovered_ports'].update(port_matches)
        
        # Extract services
        service_patterns = {
            'http': re.compile(r'80/tcp\s+open\s+http'),
            'https': re.compile(r'443/tcp\s+open\s+https'),
            'ssh': re.compile(r'22/tcp\s+open\s+ssh'),
            'ftp': re.compile(r'21/tcp\s+open\s+ftp'),
            'telnet': re.compile(r'23/tcp\s+open\s+telnet'),
            'smtp': re.compile(r'25/tcp\s+open\s+smtp')
        }
        
        for service, pattern in service_patterns.items():
            if pattern.search(output):
                state['discovered_services'].add(service)
        
        return state

    def env_response(self,
                     messages: List[Dict[str, str]],
                     state: Dict[str, Any],
                     **kwargs: Any) -> Tuple[Dict[str, str], Dict[str, Any]]:
        try:
            parsed = self.parser.parse(messages[-1]["content"])
            
            # Check if we got a valid command field
            if hasattr(parsed, 'command') and parsed.command is not None:
                output = self.run_shell_command(parsed.command)
                
                # Update the parsed object with the actual output
                parsed.output = output
                
                # Update discovery state
                state = self.update_discovery_state(parsed, state)
                
                if len(output.strip()) > 0:
                    env_response = {"role": "user", "content": self.env_parser.format(result=output)}
                    return env_response, state
                else:
                    env_response = {"role": "user", "content": "Error: Command execution returned empty output."}
                    return env_response, state
                    
        except Exception as e:
            pass
            
        env_response = {"role": "user", "content": "Error: Command not found or invalid XML format. Please use <command>your_command_here</command> format."}
        return env_response, state